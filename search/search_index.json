{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Inspector","text":"<p>O Inspector \u00e9 uma Prova de Conceito (POC), contendo aplica\u00e7\u00e3o web e scripts, escritos em Python, que analisam v\u00e1rios tipos de documentos. Ela se  utiliza de modelos de linguagem GPT-3.5 e GPT-4 da OpenAI para fornecer respostas com base em perguntas feitas pelo usu\u00e1rio.</p>"},{"location":"#funcionalidades","title":"Funcionalidades","text":"<ul> <li>Carregar Documentos: Permite ao usu\u00e1rio fazer o upload de arquivos PDF para an\u00e1lise.</li> <li>Analisar Documentos: Utiliza o LangChain e o modelo GPT-3.5-turbo para analisar documentos PDF e responder perguntas.</li> </ul>"},{"location":"#documentacao","title":"Documenta\u00e7\u00e3o","text":"<p>A documenta\u00e7\u00e3o do c\u00f3digo encontra-se em:</p> <p>https://andrecorumba.github.io/inspector/</p>"},{"location":"#exemplo-da-aplicacao","title":"Exemplo da Aplica\u00e7\u00e3o","text":"<p>Uma PoC para identificar riscos est\u00e1 dispon\u00edvel em:</p> <p>http://inspector.streamlit.app/</p>"},{"location":"#estrutura-de-diretorios","title":"Estrutura de Diret\u00f3rios","text":"<p>O projeto possui uma estrutura de diret\u00f3rios que inclui as seguintes pastas: - model: Nesta pasta, est\u00e3o arquivos Python relacionados \u00e0 modelagem ou manipula\u00e7\u00e3o de dados. - view: A pasta \"view\" cont\u00e9m arquivos Python relacionados \u00e0 interface do usu\u00e1rio. - controller: Nesta pasta, encontram-se arquivos Python relacionados \u00e0 l\u00f3gica de controle da aplica\u00e7\u00e3o. - tests: A pasta \"tests\" cont\u00e9m scripts de teste para a aplica\u00e7\u00e3o. - docs: A pasta \"docs\" cont\u00e9m documenta\u00e7\u00e3o do projeto.</p>"},{"location":"#arquivos-de-configuracao","title":"Arquivos de Configura\u00e7\u00e3o","text":"<ul> <li>.vscode: Esta pasta cont\u00e9m configura\u00e7\u00f5es e arquivos relacionados ao Visual Studio Code.</li> <li>.gitignore: O arquivo \".gitignore\" especifica quais arquivos e diret\u00f3rios devem ser ignorados pelo Git durante o versionamento do c\u00f3digo-fonte.</li> <li>LICENSE: O arquivo \"LICENSE\" cont\u00e9m informa\u00e7\u00f5es sobre a licen\u00e7a do projeto.</li> <li>README.md: O arquivo \"README.md\" cont\u00e9m essas instru\u00e7\u00f5es.</li> <li>mkdocs.yml: Arquivo de configura\u00e7\u00e3o usado para gerar documenta\u00e7\u00e3o utilizando a ferramenta MkDocs.</li> <li>poetry.lock e pyproject.toml: Esses arquivos est\u00e3o relacionados \u00e0 gest\u00e3o de depend\u00eancias e configura\u00e7\u00e3o do ambiente Python usando a ferramenta Poetry.</li> </ul>"},{"location":"#pre-requisitos","title":"Pr\u00e9-requisitos","text":"<p>Certifique-se de ter as seguintes bibliotecas instaladas:</p> <ul> <li>streamlit</li> <li>streamlit_option_menu</li> <li>openai</li> <li>dotenv</li> <li>langchain</li> </ul> <p>Voc\u00ea pode instalar as bibliotecas usando o gerenciador de pacotes <code>pip</code>. Por exemplo:</p> <pre><code>pip install streamlit\npip install streamlit-option-menu\npip install langchain\npip install openai\npip install python-dotenv\npip install pypdf\npip install tiktoken\npip install chromadb\npip install watchdog\n</code></pre>"},{"location":"#como-executar-o-projeto","title":"Como Executar o Projeto","text":"<ol> <li>Clone o reposit\u00f3rio:</li> </ol> <pre><code>git clone https://github.com/andrecorumba/inspector.git\n</code></pre> <ol> <li>Acesse o diret\u00f3rio do projeto:</li> </ol> <pre><code>cd inspector\n</code></pre> <ol> <li>Crie um arquivo <code>.env</code> na raiz do projeto com sua chave da API da OpenAI:</li> </ol> <pre><code>OPENAI_API_KEY=sua-chave-da-api-da-openai\n</code></pre> <ol> <li>Crie uma pasta oculta na raiz do projeto <code>.streamlit/secrets.toml</code> com o conte\u00fado dos usu\u00e1rios e senhas.</li> </ol> <pre><code>[passwords]\n# Follow the rule: username = \"password\"\nalice_foo = \"streamlit123\"\nbob_bar = \"mycrazypw\"\n</code></pre> <ol> <li>Execute o aplicativo com Streamlit:</li> </ol> <pre><code>streamlit run view/app_with_security.py\n</code></pre> <p>ou para app sem uso de senha digite:</p> <pre><code>streamlit run view/app.py\n</code></pre> <ol> <li>O aplicativo ser\u00e1 executado em seu navegador padr\u00e3o. Voc\u00ea pode acess\u00e1-lo em <code>http://localhost:8501</code>.</li> </ol>"},{"location":"#como-usar-o-app","title":"Como Usar o App","text":"<ol> <li> <p>Ao iniciar o aplicativo, ser\u00e1 solicitado que voc\u00ea insira seu nome de usu\u00e1rio e senha. Digite suas credenciais corretas para acessar as funcionalidades do aplicativo.</p> </li> <li> <p>Na barra lateral esquerda, voc\u00ea encontrar\u00e1 as diferentes op\u00e7\u00f5es dispon\u00edveis: \"Home\", \"Carregar Documentos\", etc.</p> </li> <li> <p>Selecione a op\u00e7\u00e3o desejada e siga as instru\u00e7\u00f5es para utilizar cada funcionalidade do aplicativo.</p> </li> </ol>"},{"location":"#observacoes","title":"Observa\u00e7\u00f5es","text":"<ul> <li>Certifique-se de que sua chave da API da OpenAI esteja correta e configurada corretamente no arquivo <code>.env</code>.</li> </ul>"},{"location":"#autores","title":"Autores","text":"<ul> <li>andrecorumba</li> </ul>"},{"location":"#contribuicoes","title":"Contribui\u00e7\u00f5es","text":"<p>Contribui\u00e7\u00f5es s\u00e3o bem-vindas! Sinta-se \u00e0 vontade para abrir um \"issue\" ou enviar um \"pull request\" com melhorias ou corre\u00e7\u00f5es.</p>"},{"location":"#licenca","title":"Licen\u00e7a","text":"<p>Este projeto est\u00e1 licenciado sob a Licen\u00e7a MIT - consulte o arquivo LICENSE para obter mais detalhes.</p>"},{"location":"#descricao-das-funcoes-principais-de-cada-arquivo","title":"Descri\u00e7\u00e3o das fun\u00e7\u00f5es principais de cada arquivo:","text":""},{"location":"#apppy","title":"<code>app.py</code>","text":"<p>O arquivo <code>app.py</code> cont\u00e9m a fun\u00e7\u00e3o principal do projeto chamada <code>main()</code>. Essa fun\u00e7\u00e3o \u00e9 respons\u00e1vel por criar a interface do usu\u00e1rio do aplicativo utilizando o framework Streamlit. O app tem um menu lateral que permite ao usu\u00e1rio escolher entre diferentes op\u00e7\u00f5es, como carregar documentos, analisar documentos PDF, elaborar matriz de planejamento, analisar conversas do WhatsApp e escrever relat\u00f3rios.</p> <p>A fun\u00e7\u00e3o <code>main()</code> \u00e9 executada quando o arquivo <code>app.py</code> \u00e9 executado diretamente. Ela verifica se a senha do usu\u00e1rio \u00e9 correta usando a fun\u00e7\u00e3o <code>password.check_password()</code>. Em seguida, dependendo da op\u00e7\u00e3o selecionada pelo usu\u00e1rio no menu lateral, ele \u00e9 redirecionado para a p\u00e1gina correspondente.</p>"},{"location":"#py_pdf_inspectorpy","title":"<code>py_pdf_inspector.py</code>","text":"<p>O arquivo <code>py_pdf_inspector.py</code> cont\u00e9m a classe <code>PyPDFInspector</code>, que \u00e9 respons\u00e1vel por analisar arquivos PDF.</p>"},{"location":"#passwordpy","title":"<code>password.py</code>","text":"<p>O arquivo <code>password.py</code> cont\u00e9m a fun\u00e7\u00e3o <code>check_password()</code>, que \u00e9 respons\u00e1vel por verificar se a senha inserida pelo usu\u00e1rio est\u00e1 correta. Ela utiliza o framework Streamlit para exibir campos de entrada para o nome de usu\u00e1rio e senha. Se a senha estiver correta, a fun\u00e7\u00e3o retorna <code>True</code>, caso contr\u00e1rio, retorna <code>False</code>.</p>"},{"location":"#folderspy","title":"<code>folders.py</code>","text":"<p>O arquivo <code>folders.py</code> cont\u00e9m a fun\u00e7\u00e3o <code>create_folders(user_folder, work_key)</code>, que \u00e9 respons\u00e1vel por criar as pastas necess\u00e1rias para o funcionamento do aplicativo. Ela recebe o caminho da pasta principal do usu\u00e1rio e uma chave aleat\u00f3ria como entrada e cria as pastas relacionadas ao trabalho do usu\u00e1rio.</p>"},{"location":"#work_keypy","title":"<code>work_key.py</code>","text":"<p>O arquivo <code>work_key.py</code> cont\u00e9m a fun\u00e7\u00e3o <code>create_key(type_of_work)</code>, que \u00e9 respons\u00e1vel por criar uma chave aleat\u00f3ria para identificar o caso de uso do app.</p> <p>Outras funcionalidades ainda em constru\u00e7\u00e3o.</p>"},{"location":"#bibliotecas-usadas","title":"Bibliotecas usadas:","text":"<ul> <li><code>streamlit</code>: Um framework de cria\u00e7\u00e3o de aplicativos web interativos com Python.</li> <li><code>streamlit_option_menu</code>: Uma extens\u00e3o do Streamlit que permite criar menus de sele\u00e7\u00e3o personalizados.</li> <li><code>openai</code>: Uma biblioteca de Python para interagir com a API da OpenAI e usar modelos de linguagem como o GPT-3.5-turbo.</li> <li><code>dotenv</code>: Uma biblioteca para carregar vari\u00e1veis de ambiente a partir de um arquivo <code>.env</code>.</li> <li><code>langchain</code>: Uma biblioteca para processamento de linguagem natural e uso do modelo GPT-3.5-turbo da OpenAI.</li> <li><code>os</code>: Uma biblioteca que permite interagir com o sistema operacional, como criar pastas e manipular arquivos.</li> <li><code>string</code>: Uma biblioteca para manipular strings em Python, utilizada para gerar chaves aleat\u00f3rias.</li> <li><code>random</code>: Uma biblioteca para gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios em Python.</li> </ul>"},{"location":"#para-depurar-o-projeto-no-vscode","title":"Para Depurar o Projeto no VSCode:","text":"<p>O arquivo launch.json \u00e9 uma parte essencial do ambiente de desenvolvimento para projetos Python no Visual Studio Code. Ele \u00e9 usado para configurar e definir as configura\u00e7\u00f5es de depura\u00e7\u00e3o (debug) para um projeto espec\u00edfico. No exemplo abaixo, explicarei as diferentes propriedades do arquivo launch.json e o que elas significam Altere o arquivo <code>launch.json</code> constante da pasta <code>.vscode</code> para o conte\u00fado a seguir:</p> <pre><code>{\n    // Use IntelliSense to learn about possible attributes.\n    // Hover to view descriptions of existing attributes.\n    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"Streamlit\",\n            \"type\": \"python\",\n            \"request\": \"launch\",\n            \"program\": \".venv/bin/streamlit\",\n            \"console\": \"integratedTerminal\",\n            \"justMyCode\": true,\n            \"args\": [\"run\", \"inspector/app.py\"]\n        }\n    ]\n}\n</code></pre>"},{"location":"controller/folders/","title":"folders.py","text":""},{"location":"controller/folders/#controller.folders.create_folders","title":"<code>create_folders(user_folder, work_key)</code>","text":"<p>Create folders necessary to works.</p> <p>Parameters: folder_user (str): Path to the user folder.</p> Source code in <code>controller/folders.py</code> <pre><code>def create_folders(user_folder, work_key):\n\"\"\"\n    Create folders necessary to works.\n\n    Parameters:\n    folder_user (str): Path to the user folder.\n    \"\"\"\n\n    # Create user folder if not exists\n    if not os.path.exists(user_folder):\n        os.makedirs(user_folder)\n\n    # Tra\u00e7a o caminho e cria a para a folder do trabalho do usu\u00e1rio\n    work_folder = os.path.join(user_folder, work_key)\n    if not os.path.exists(work_folder):\n        os.makedirs(work_folder)\n\n    # Caminho para as subfolders de cada trabalho chave_ide\n    vectordb_folder = os.path.join(work_folder, \"vectordb\")\n    download_folder = os.path.join(work_folder, \"download\")\n    responses_folder = os.path.join(work_folder, \"responses\")\n    upload_folder= os.path.join(work_folder, \"upload\")\n\n    # Cria as subfolders caso n\u00e3o existam\n    for subfolder_path in [vectordb_folder, download_folder, responses_folder, upload_folder]:\n        if not os.path.exists(subfolder_path):\n            os.makedirs(subfolder_path)\n</code></pre>"},{"location":"controller/prompts/","title":"prompts.py","text":""},{"location":"controller/prompts/#portugues-prompts","title":"Portugues prompts","text":"<pre><code>from langchain.prompts import PromptTemplate\n\nprompt_template = \"\"\"\nA partir de trechos de documentos constantes do contexto a seguir e responda a pergunta do usu\u00e1rio.\nContexto: {context}\nPergunta: {question}\nA resposta deve ser clara, direta e formal em portugu\u00eas, seguindo o conte\u00fado do contexto.\nVoc\u00ea dever\u00e1 responder apenas se houver uma resposta no contexto acima, caso contr\u00e1rio escreva apenas: \n\"N\u00e3o consegui encontrar a resposta nos documentos fornecidos.\"\n\"\"\"\nPORTUGUESE_BASIC_PROMPT = PromptTemplate.from_template(prompt_template)\n</code></pre>"},{"location":"controller/public_contest/","title":"public_contest.py","text":""},{"location":"controller/public_contest/#controller.public_contest.edital_analyzer","title":"<code>edital_analyzer(file_pdf)</code>","text":"<p>Module to get informations about public contests.</p> Source code in <code>controller/public_contest.py</code> <pre><code>def edital_analyzer(file_pdf):\n\"\"\"Module to get informations about public contests.\"\"\"\n    docs = load_file(file_pdf)\n</code></pre>"},{"location":"controller/public_contest/#controller.public_contest.load_env_file","title":"<code>load_env_file()</code>","text":"<p>Function to load the .env file.</p> Source code in <code>controller/public_contest.py</code> <pre><code>def load_env_file():\n\"\"\"Function to load the .env file.\"\"\"\n    _ = load_dotenv(find_dotenv())\n    openai.api_key = os.environ['OPENAI_API_KEY']\n</code></pre>"},{"location":"controller/public_contest/#controller.public_contest.load_file","title":"<code>load_file(file_pdf)</code>","text":"<p>Function to load the pdf file.</p> Source code in <code>controller/public_contest.py</code> <pre><code>def load_file(file_pdf):\n\"\"\"Function to load the pdf file.\"\"\"\n    loader = PyPDFLoader(file_pdf)\n    documents = loader.load()\n    return documents\n</code></pre>"},{"location":"controller/public_contest/#controller.public_contest.split_document","title":"<code>split_document(documents, model_name='gpt-3.5-turbo-16k', chunk_size=10000, chunk_overlap=200)</code>","text":"<p>Function to split the document.</p> Source code in <code>controller/public_contest.py</code> <pre><code>def split_document(documents, \n                   model_name=\"gpt-3.5-turbo-16k\", \n                   chunk_size=10000, \n                   chunk_overlap=200):\n\"\"\"Function to split the document.\"\"\"\n    splitter = TokenTextSplitter(model_name==model_name)\n    documents_splited = splitter.split_text(documents)\n    return documents_splited\n</code></pre>"},{"location":"controller/work_key/","title":"controller/work_key.py","text":""},{"location":"controller/work_key/#controller.work_key.create_key","title":"<code>create_key(type_of_work)</code>","text":"<p>Fun\u00e7\u00e3o que cria uma chave aleat\u00f3ria para identificar o caso de uso do app.</p> Par\u00e2metros <p>tipo_de_trabalho (str): Tipo de trabalho que o usu\u00e1rio est\u00e1 fazendo. Use sem espa\u00e7os.</p> Retornos <p>Chave (str): Chave aleat\u00f3ria de 08 caracteres.</p> Source code in <code>controller/work_key.py</code> <pre><code>def create_key(type_of_work):\n''' \n    Fun\u00e7\u00e3o que cria uma chave aleat\u00f3ria para identificar o caso de uso do app.\n\n    Par\u00e2metros:\n        tipo_de_trabalho (str): Tipo de trabalho que o usu\u00e1rio est\u00e1 fazendo. Use sem espa\u00e7os.\n\n    Retornos:\n        Chave (str): Chave aleat\u00f3ria de 08 caracteres.\n    '''\n\n    # Create a random combination of letters and numbers\n    len_key = 6\n    # letters = string.ascii_letters + string.digits\n    # combination = ''.join(random.choice(letters) for _ in range(len_key))\n    combination = ''.join(random.choice(string.digits) for _ in range(len_key))\n\n    # Concatenate the type of work with the combination\n    key = type_of_work + '_' + combination\n    # key = str(uuid.uuid4())\n\n    return key\n</code></pre>"},{"location":"model/py_pdf_inspector/","title":"py_pdf_inspector.py","text":""},{"location":"model/py_pdf_inspector/#model.py_pdf_inspector.PyPDFInspector","title":"<code>PyPDFInspector</code>","text":"Source code in <code>model/py_pdf_inspector.py</code> <pre><code>class PyPDFInspector():\n    def __init__ (\n            self, \n            model_name = \"gpt-3.5-turbo-16k\",\n            temperature = 0,\n            chunk_size = 4000,\n            ):\n'''Initialize the ChatAuditReport class.'''\n        self.model_name = model_name \n        self.documents = None\n        self.docs_splited = None\n        self.chunk_size = chunk_size\n        self.embeddings = None\n        self.vector_db = None\n        self.prompt = None\n        self.llm = None\n        self.temperature = temperature\n        self.qa_chain = None\n        self.response = None\n\n\n    def load_pdf_report_from_path(self, path_to_pdf_report: str):\n'''Load PDF report.'''\n        if os.path.isfile(path_to_pdf_report):\n            loader = PyPDFLoader(path_to_pdf_report)\n            self.documents = loader.load()\n        else:\n            raise FileNotFoundError(\"File not found. Please check the path to the PDF report.\")\n        return self.documents\n\n    def load_pdf_folder(self, path_to_pdf_report):\n'''Load PDF folder.'''\n        if os.path.isdir(path_to_pdf_report):\n            loader = PyPDFDirectoryLoader(path_to_pdf_report)\n            self.documents = loader.load()\n        else:\n            raise FileNotFoundError(\"Folder not found. Please check the path to the PDF folder.\")\n        return self.documents\n\n    def split_documents_from_tiktoken_encoder(self):\n'''Split the documents from TikToken encoder.\n        See https://python.langchain.com/docs/modules/data_connection/document_transformers/text_splitters/split_by_token \n        Default chunk_size from TextSplitter class are 4000 caracters.'''\n        text_splitter = RecursiveCharacterTextSplitter.from_tiktoken_encoder(\n            model_name=self.model_name\n            )\n        self.chunk_size = text_splitter._chunk_size\n        self.docs_splited = text_splitter.split_documents(self.documents)\n        return self.docs_splited\n\n    def load_openai_enviroment(self):\n'''Load the OpenAI enviroment.\n        Need OpenAI API key. Get it from https://platform.openai.com/account/api-keys'''\n        _ = load_dotenv(find_dotenv())\n        openai.api_key = os.environ['OPENAI_API_KEY']\n\n    def create_openai_embeddings(self):\n'''Create the embeddings from OpenAI.'''\n        self.load_openai_enviroment()\n        self.embeddings = OpenAIEmbeddings(\n            openai_api_key=openai.api_key,\n            chunk_size=self.chunk_size,\n            max_retries=3,\n            )\n\n    def chroma_vector_db(\n            self,\n            persistent_folder: str,\n            ):\n'''Create the Chroma vector database.'''\n        self.create_openai_embeddings()\n        self.vector_db = Chroma.from_documents(\n            documents=self.docs_splited,\n            embedding=self.embeddings,\n            collection_name=\"py_pdf_inspector_store\",\n            persist_directory=persistent_folder,\n            )\n        self.vector_db.persist()\n\n    def openai_llm(self):\n'''Create the OpenAI LLM.'''\n        self.llm = ChatOpenAI(\n            model=\"gpt-3.5-turbo-16k\", \n            temperature=self.temperature,\n            max_tokens=4052,\n            )\n\n    def azure_openai_llm(self):\n'''Create Azure OpenAI LLM.'''\n        self.llm = AzureChatOpenAI(\n            model=\"gpt-3.5-turbo-16k\", \n            temperature=self.temperature,\n            openai_api_version='2023-05-15',\n            deployment_name='Teste-16k',\n            max_tokens=4052,\n            )\n\n    def load_prompt_template(self, prompt_template=None):\n'''Load the prompt template.'''\n        if prompt_template == None:\n            prompt_template = \"\"\"\n            Using excerpts from documents contained in the context below, answer the user's question.\n            Context: {context}\n            Question: {question}\n            The answer must be clear, direct and formal in English, following the content of the context.\n            You should only respond if there is an answer in the context above, otherwise just write:\n            'I was unable to find the answer in the documents provided.'\n            \"\"\"\n        self.prompt = PromptTemplate.from_template(prompt_template)\n        return self.prompt\n\n    def retrieval_qa_chain(self):\n'''Create the Retrieval QA chain.'''\n        self.qa_chain = RetrievalQA.from_chain_type(\n            llm=self.llm,\n            retriever=self.vector_db.as_retriever(search_kwargs={\"k\": 1}),\n            return_source_documents=True,\n            chain_type_kwargs={\"prompt\": self.prompt},\n            )\n        return self.qa_chain\n\n    def inspector_qa_chains(self, query):\n        self.response = self.qa_chain({'query': query})\n        return self.response\n\n    def run_pdf_inspector_from_folder(\n            self, \n            file_path: str, \n            persistent_folder: str,\n            model_name=None, \n            temperature=None,\n            ):\n'''Run the PDF inspector.'''\n        if model_name is not None:\n            self.model_name = model_name\n        if temperature is not None:\n            self.temperature = temperature\n        try:\n            self.load_pdf_folder(path_to_pdf_report=file_path)\n            self.split_documents_from_tiktoken_encoder()\n            self.chroma_vector_db(persistent_folder=persistent_folder)\n            self.openai_llm()\n            self.retrieval_qa_chain()\n        except Exception as e:\n            print(f\"An error occurred during PDF inspection: {str(e)}\")\n\n    def load_persistent_chroma_vector_db_and_retrieval(\n            self, \n            persistent_folder: str,\n            ):\n'''Load the persistent Chroma vector database.'''\n        try:\n            self.create_openai_embeddings()\n            self.vector_db = Chroma(\n                collection_name=\"py_pdf_inspector_store\",\n                persist_directory=persistent_folder, \n                embedding_function=self.embeddings,\n                )\n            self.openai_llm()\n            self.retrieval_qa_chain()\n        except Exception as e:\n            print(f\"An error occurred during PDF inspection: {str(e)}\")\n</code></pre>"},{"location":"model/py_pdf_inspector/#model.py_pdf_inspector.PyPDFInspector.__init__","title":"<code>__init__(model_name='gpt-3.5-turbo-16k', temperature=0, chunk_size=4000)</code>","text":"<p>Initialize the ChatAuditReport class.</p> Source code in <code>model/py_pdf_inspector.py</code> <pre><code>def __init__ (\n        self, \n        model_name = \"gpt-3.5-turbo-16k\",\n        temperature = 0,\n        chunk_size = 4000,\n        ):\n'''Initialize the ChatAuditReport class.'''\n    self.model_name = model_name \n    self.documents = None\n    self.docs_splited = None\n    self.chunk_size = chunk_size\n    self.embeddings = None\n    self.vector_db = None\n    self.prompt = None\n    self.llm = None\n    self.temperature = temperature\n    self.qa_chain = None\n    self.response = None\n</code></pre>"},{"location":"model/py_pdf_inspector/#model.py_pdf_inspector.PyPDFInspector.azure_openai_llm","title":"<code>azure_openai_llm()</code>","text":"<p>Create Azure OpenAI LLM.</p> Source code in <code>model/py_pdf_inspector.py</code> <pre><code>def azure_openai_llm(self):\n'''Create Azure OpenAI LLM.'''\n    self.llm = AzureChatOpenAI(\n        model=\"gpt-3.5-turbo-16k\", \n        temperature=self.temperature,\n        openai_api_version='2023-05-15',\n        deployment_name='Teste-16k',\n        max_tokens=4052,\n        )\n</code></pre>"},{"location":"model/py_pdf_inspector/#model.py_pdf_inspector.PyPDFInspector.chroma_vector_db","title":"<code>chroma_vector_db(persistent_folder)</code>","text":"<p>Create the Chroma vector database.</p> Source code in <code>model/py_pdf_inspector.py</code> <pre><code>def chroma_vector_db(\n        self,\n        persistent_folder: str,\n        ):\n'''Create the Chroma vector database.'''\n    self.create_openai_embeddings()\n    self.vector_db = Chroma.from_documents(\n        documents=self.docs_splited,\n        embedding=self.embeddings,\n        collection_name=\"py_pdf_inspector_store\",\n        persist_directory=persistent_folder,\n        )\n    self.vector_db.persist()\n</code></pre>"},{"location":"model/py_pdf_inspector/#model.py_pdf_inspector.PyPDFInspector.create_openai_embeddings","title":"<code>create_openai_embeddings()</code>","text":"<p>Create the embeddings from OpenAI.</p> Source code in <code>model/py_pdf_inspector.py</code> <pre><code>def create_openai_embeddings(self):\n'''Create the embeddings from OpenAI.'''\n    self.load_openai_enviroment()\n    self.embeddings = OpenAIEmbeddings(\n        openai_api_key=openai.api_key,\n        chunk_size=self.chunk_size,\n        max_retries=3,\n        )\n</code></pre>"},{"location":"model/py_pdf_inspector/#model.py_pdf_inspector.PyPDFInspector.load_openai_enviroment","title":"<code>load_openai_enviroment()</code>","text":"<p>Load the OpenAI enviroment. Need OpenAI API key. Get it from https://platform.openai.com/account/api-keys</p> Source code in <code>model/py_pdf_inspector.py</code> <pre><code>def load_openai_enviroment(self):\n'''Load the OpenAI enviroment.\n    Need OpenAI API key. Get it from https://platform.openai.com/account/api-keys'''\n    _ = load_dotenv(find_dotenv())\n    openai.api_key = os.environ['OPENAI_API_KEY']\n</code></pre>"},{"location":"model/py_pdf_inspector/#model.py_pdf_inspector.PyPDFInspector.load_pdf_folder","title":"<code>load_pdf_folder(path_to_pdf_report)</code>","text":"<p>Load PDF folder.</p> Source code in <code>model/py_pdf_inspector.py</code> <pre><code>def load_pdf_folder(self, path_to_pdf_report):\n'''Load PDF folder.'''\n    if os.path.isdir(path_to_pdf_report):\n        loader = PyPDFDirectoryLoader(path_to_pdf_report)\n        self.documents = loader.load()\n    else:\n        raise FileNotFoundError(\"Folder not found. Please check the path to the PDF folder.\")\n    return self.documents\n</code></pre>"},{"location":"model/py_pdf_inspector/#model.py_pdf_inspector.PyPDFInspector.load_pdf_report_from_path","title":"<code>load_pdf_report_from_path(path_to_pdf_report)</code>","text":"<p>Load PDF report.</p> Source code in <code>model/py_pdf_inspector.py</code> <pre><code>def load_pdf_report_from_path(self, path_to_pdf_report: str):\n'''Load PDF report.'''\n    if os.path.isfile(path_to_pdf_report):\n        loader = PyPDFLoader(path_to_pdf_report)\n        self.documents = loader.load()\n    else:\n        raise FileNotFoundError(\"File not found. Please check the path to the PDF report.\")\n    return self.documents\n</code></pre>"},{"location":"model/py_pdf_inspector/#model.py_pdf_inspector.PyPDFInspector.load_persistent_chroma_vector_db_and_retrieval","title":"<code>load_persistent_chroma_vector_db_and_retrieval(persistent_folder)</code>","text":"<p>Load the persistent Chroma vector database.</p> Source code in <code>model/py_pdf_inspector.py</code> <pre><code>def load_persistent_chroma_vector_db_and_retrieval(\n        self, \n        persistent_folder: str,\n        ):\n'''Load the persistent Chroma vector database.'''\n    try:\n        self.create_openai_embeddings()\n        self.vector_db = Chroma(\n            collection_name=\"py_pdf_inspector_store\",\n            persist_directory=persistent_folder, \n            embedding_function=self.embeddings,\n            )\n        self.openai_llm()\n        self.retrieval_qa_chain()\n    except Exception as e:\n        print(f\"An error occurred during PDF inspection: {str(e)}\")\n</code></pre>"},{"location":"model/py_pdf_inspector/#model.py_pdf_inspector.PyPDFInspector.load_prompt_template","title":"<code>load_prompt_template(prompt_template=None)</code>","text":"<p>Load the prompt template.</p> Source code in <code>model/py_pdf_inspector.py</code> <pre><code>def load_prompt_template(self, prompt_template=None):\n'''Load the prompt template.'''\n    if prompt_template == None:\n        prompt_template = \"\"\"\n        Using excerpts from documents contained in the context below, answer the user's question.\n        Context: {context}\n        Question: {question}\n        The answer must be clear, direct and formal in English, following the content of the context.\n        You should only respond if there is an answer in the context above, otherwise just write:\n        'I was unable to find the answer in the documents provided.'\n        \"\"\"\n    self.prompt = PromptTemplate.from_template(prompt_template)\n    return self.prompt\n</code></pre>"},{"location":"model/py_pdf_inspector/#model.py_pdf_inspector.PyPDFInspector.openai_llm","title":"<code>openai_llm()</code>","text":"<p>Create the OpenAI LLM.</p> Source code in <code>model/py_pdf_inspector.py</code> <pre><code>def openai_llm(self):\n'''Create the OpenAI LLM.'''\n    self.llm = ChatOpenAI(\n        model=\"gpt-3.5-turbo-16k\", \n        temperature=self.temperature,\n        max_tokens=4052,\n        )\n</code></pre>"},{"location":"model/py_pdf_inspector/#model.py_pdf_inspector.PyPDFInspector.retrieval_qa_chain","title":"<code>retrieval_qa_chain()</code>","text":"<p>Create the Retrieval QA chain.</p> Source code in <code>model/py_pdf_inspector.py</code> <pre><code>def retrieval_qa_chain(self):\n'''Create the Retrieval QA chain.'''\n    self.qa_chain = RetrievalQA.from_chain_type(\n        llm=self.llm,\n        retriever=self.vector_db.as_retriever(search_kwargs={\"k\": 1}),\n        return_source_documents=True,\n        chain_type_kwargs={\"prompt\": self.prompt},\n        )\n    return self.qa_chain\n</code></pre>"},{"location":"model/py_pdf_inspector/#model.py_pdf_inspector.PyPDFInspector.run_pdf_inspector_from_folder","title":"<code>run_pdf_inspector_from_folder(file_path, persistent_folder, model_name=None, temperature=None)</code>","text":"<p>Run the PDF inspector.</p> Source code in <code>model/py_pdf_inspector.py</code> <pre><code>def run_pdf_inspector_from_folder(\n        self, \n        file_path: str, \n        persistent_folder: str,\n        model_name=None, \n        temperature=None,\n        ):\n'''Run the PDF inspector.'''\n    if model_name is not None:\n        self.model_name = model_name\n    if temperature is not None:\n        self.temperature = temperature\n    try:\n        self.load_pdf_folder(path_to_pdf_report=file_path)\n        self.split_documents_from_tiktoken_encoder()\n        self.chroma_vector_db(persistent_folder=persistent_folder)\n        self.openai_llm()\n        self.retrieval_qa_chain()\n    except Exception as e:\n        print(f\"An error occurred during PDF inspection: {str(e)}\")\n</code></pre>"},{"location":"model/py_pdf_inspector/#model.py_pdf_inspector.PyPDFInspector.split_documents_from_tiktoken_encoder","title":"<code>split_documents_from_tiktoken_encoder()</code>","text":"<p>Split the documents from TikToken encoder. See https://python.langchain.com/docs/modules/data_connection/document_transformers/text_splitters/split_by_token  Default chunk_size from TextSplitter class are 4000 caracters.</p> Source code in <code>model/py_pdf_inspector.py</code> <pre><code>def split_documents_from_tiktoken_encoder(self):\n'''Split the documents from TikToken encoder.\n    See https://python.langchain.com/docs/modules/data_connection/document_transformers/text_splitters/split_by_token \n    Default chunk_size from TextSplitter class are 4000 caracters.'''\n    text_splitter = RecursiveCharacterTextSplitter.from_tiktoken_encoder(\n        model_name=self.model_name\n        )\n    self.chunk_size = text_splitter._chunk_size\n    self.docs_splited = text_splitter.split_documents(self.documents)\n    return self.docs_splited\n</code></pre>"},{"location":"view/app/","title":"App","text":""},{"location":"view/app/#view.app.main","title":"<code>main()</code>","text":"<p>Main function for the Inspector App.</p> Source code in <code>view/app.py</code> <pre><code>def main():\n\"\"\" Main function for the Inspector App. \"\"\"\n    with st.sidebar:\n        st.write(\"Usu\u00e1rio da sess\u00e3o:\", 'user')\n        option = option_menu(\"Inspector v.0.1.1\",\n                            options=[\"P\u00e1gina Inicial\", \n                                     \"Carregar Documentos\",\n                                     \"Interagir com Documentos\",\n                                     ],                    \n                            # Icons from https://icons.getbootstrap.com/\n                            icons=[\"house\", \n                                   \"archive\",\n                                   \"chat-dots\",\n                                   ]\n                                   )   \n    if option == \"P\u00e1gina Inicial\":\n        st.title(\"P\u00e1gina Inicial\")\n        st.markdown(\"\"\"O **Inspector** \u00e9 uma POC de aplica\u00e7\u00e3o web, escrita em Python, \n                    que analisa e interage com v\u00e1rios tipos de documentos.\n                    \"\"\")   \n    elif option == \"Carregar Documentos\":   \n        app_upload_files.upload_files(type=['pdf'])\n    elif option == \"Interagir com Documentos\":   \n        app_py_pdf_inspector.app('user')\n</code></pre>"},{"location":"view/app_py_pdf_inspector/","title":"app_py_pdf_inspector.py","text":""},{"location":"view/app_py_pdf_inspector/#view.app_py_pdf_inspector.app","title":"<code>app(user)</code>","text":"<p>App for PDF Inspector</p> Source code in <code>view/app_py_pdf_inspector.py</code> <pre><code>def app(user):\n'''App for PDF Inspector'''\n    user_work_list = []\n    user_folder = folders.get_folder(\n            user=user,\n            work_key='todos',\n            type_of_folder='user_folder'\n            )\n    for item in os.listdir(user_folder):\n        if not item.startswith('.'):\n            user_work_list.append(item)\n\n    with st.sidebar:\n        option_work = st.selectbox(\n            label=\"Lista de Trabalhos\",\n            options=user_work_list\n            )\n        st.write('Voc\u00ea Selecionou:', option_work)\n        st.radio('Selecione', options=[# 'Mostrar Hist\u00f3rio',\n                                        'Fazer Minhas Perguntas',\n                                        'Gerar Perguntas Prontas',], \n                                        key='radio_show_questions')\n\n    if st.session_state['radio_show_questions'] == 'Fazer Minhas Perguntas':\n        if query:=st.text_input(\"Digite sua pergunta:\"):  \n            report = PyPDFInspector()\n\n            report.prompt = prompts.PORTUGUESE_BASIC_PROMPT\n            report.load_persistent_chroma_vector_db_and_retrieval(\n                persistent_folder=os.path.join(\n                    user_folder,\n                    option_work, \n                    'vectordb',\n                    ),\n                )    \n            report.inspector_qa_chains(query=query)\n            st.write(report.response)\n\n    elif st.session_state['radio_show_questions'] == 'Gerar Perguntas Prontas':\n            first_questions = PyPDFInspector(\n                 temperature=0.3\n                 )\n            first_questions.prompt = prompts.FIRST_QUESTIONS_PORTUGUESE_PROMPT\n            first_questions.load_persistent_chroma_vector_db_and_retrieval(\n                persistent_folder=os.path.join(\n                    user_folder,\n                    option_work, \n                    'vectordb',\n                    ),\n                )    \n            first_questions.inspector_qa_chains(query=' ')\n            st.write(first_questions.response)\n</code></pre>"},{"location":"view/app_upload_files/","title":"app_upload_files.py","text":""},{"location":"view/app_upload_files/#view.app_upload_files.upload_files","title":"<code>upload_files(type, type_of_work='report', user='user')</code>","text":"<p>Function to upload files to the user folder.</p> Source code in <code>view/app_upload_files.py</code> <pre><code>def upload_files(\n    type: list[str],\n    type_of_work: str = 'report', \n    user: str = 'user') -&gt; str:\n\"\"\"Function to upload files to the user folder.\"\"\"\n\n    st.file_uploader(\n        'Selecione os arquivos para an\u00e1lise', \n        type=type,\n        accept_multiple_files=True,\n        key='uploaded_file_list'\n        )\n\n    if st.session_state['uploaded_file_list'] is not None:\n        if st.button('Processar Arquivos'):\n            user_folder = os.path.join(\n                os.path.dirname(os.path.abspath(__file__)),\n                '..',\n                'data',\n                user\n                )\n            key = work_key.create_key(type_of_work)\n\n            # Create and get folders to work\n            folders.create_folders(user_folder, key)\n            files_folder = folders.get_folder(user, key, 'upload')\n            vectordb_folder = folders.get_folder(user, key, 'vectordb')\n\n            for file in st.session_state['uploaded_file_list']:\n                with open(os.path.join(files_folder, file.name),\"wb\") as f:\n                    f.write((file).getbuffer())\n            files_lenght = len(os.listdir(files_folder))\n\n            # Run the PDF Inspector\n            report = PyPDFInspector()\n            report.run_pdf_inspector_from_folder(\n                file_path=files_folder,\n                persistent_folder=vectordb_folder,\n                )\n            st.success(f\"Arquivos Carregados: {files_lenght}. C\u00f3digo do trabalho: {key}\")\n\n            return key\n</code></pre>"},{"location":"view/app_with_security/","title":"app_with_security.py","text":""},{"location":"view/app_with_security/#view.app_with_security.get_questions","title":"<code>get_questions(user, work_key)</code>","text":"<p>Funtion to get all questions.</p> <p>Parameters: user (str): User name. work_key (str): Work key.</p> <p>Return: questions (list): List of questions.</p> Source code in <code>view/app_with_security.py</code> <pre><code>def get_questions(user, work_key):\n\"\"\"\n    Funtion to get all questions.\n\n    Parameters:\n    user (str): User name.\n    work_key (str): Work key.\n\n    Return:\n    questions (list): List of questions.\n    \"\"\"\n\n    response_folder = folders.get_folder(user, \n                                        work_key, \n                                        'response')\n\n    questions = pdf_inspector.generate_first_questions(password.user, work_key)  \n\n    # with open(os.path.join(response_folder, 'qa.json'), 'r') as f:\n    #     qa = json.load(f)\n    #     questions = qa[0]['result'].split('\\n')\n\n    return questions\n</code></pre>"},{"location":"view/app_with_security/#view.app_with_security.main","title":"<code>main()</code>","text":"<p>Main function for the Inspector App.</p> Source code in <code>view/app_with_security.py</code> <pre><code>def main():\n\"\"\" Main function for the Inspector App. \"\"\"\n\n    if password.check_password():\n\n        with st.sidebar:\n            st.write(\"Usu\u00e1rio da sess\u00e3o:\", password.user)\n\n            option = option_menu(\"Inspector v.0.1.0\",\n                                options=[\"P\u00e1gina Inicial\", \n                                        \"Carregar Documentos\", \n                                        \"Analisar Documentos\",\n                                        ],\n\n                                # Icons from https://icons.getbootstrap.com/\n                                icons=['house', \n                                       \"filetype-pdf\",\n                                       \"search\",\n                                       ])   \n\n        if option == \"P\u00e1gina Inicial\":\n            st.title(\"P\u00e1gina Inicial\")\n            st.markdown(\"\"\"O **Inspector** \u00e9 uma aplica\u00e7\u00e3o web, escrita em Python, \n                        que analisa v\u00e1rios tipos de documentos.\n                        \"\"\")   \n\n        elif option == \"Carregar Documentos\":\n            st.title(\"Carregar Documentos\")\n            st.write(\"P\u00e1gina para analisar documentos.\")\n\n            work_key = app_upload_files.upload_files(type=['pdf'], \n                                                     type_of_work='documentos',\n                                                     user=password.user)\n            if work_key:\n                pdf_inspector.pdf_load_split_vector(password.user, work_key)\n\n        elif option == \"Analisar Documentos\":   \n            try:\n                user_work_list = []\n                for item in os.listdir(folders.get_folder(user=password.user,\n                                                        work_key='todos',\n                                                        type_of_folder='user_folder')):\n                    if not item.startswith('.'):\n                        user_work_list.append(item)\n\n                with st.sidebar:\n                    option_work = st.selectbox(label=\"Lista de Trabalhos\",\n                                               options=user_work_list)\n                    st.write('Voc\u00ea Selecionou:', option_work)\n\n                    st.radio('Selecione', options=[# 'Mostrar Hist\u00f3rio',\n                                                   'Fazer Minhas Perguntas',\n                                                   'Gerar Perguntas Prontas',], \n                                                   key='radio_show_questions')\n\n                if st.session_state['radio_show_questions'] == 'Fazer Minhas Perguntas':\n                    if query:=st.text_input(\"Digite sua pergunta:\"):                          \n                        pdf_inspector.user_questions(password.user, option_work, query)\n\n                # if st.session_state['radio_show_questions'] == 'Mostrar Hist\u00f3rio':\n                #     show_all(password.user, option_work)\n\n                elif st.session_state['radio_show_questions'] == 'Gerar Perguntas Prontas':\n                    get_questions(password.user, option_work)\n\n\n            except FileNotFoundError:\n                st.warning('N\u00e3o h\u00e1 trabalhos para analisar. Por favor, carregue documentos.')\n                return\n</code></pre>"},{"location":"view/app_with_security/#view.app_with_security.show_all","title":"<code>show_all(user, work_key)</code>","text":"<p>Function to show all questions and answers.</p> <p>Parameters: user (str): User name. work_key (str): Work key.</p> <p>Return: None</p> Source code in <code>view/app_with_security.py</code> <pre><code>def show_all(user, work_key):\n\"\"\"\n    Function to show all questions and answers.\n\n    Parameters:\n    user (str): User name.\n    work_key (str): Work key.\n\n    Return:\n    None\n    \"\"\"\n\n    response_folder = folders.get_folder(user, \n                                         work_key, \n                                         'response')\n\n    # Verifica se existe o arquivo qa.txt\n    if not os.path.exists(os.path.join(response_folder, 'qa.txt')):\n        st.warning('N\u00e3o h\u00e1 perguntas e respostas para mostrar. Fa\u00e7a perguntas.')\n\n        with open(os.path.join(response_folder, 'qa.txt'), 'r') as f:\n            qa = f.readlines()\n            for line in qa:\n                st.write(line)\n</code></pre>"},{"location":"view/password/","title":"Password","text":""},{"location":"view/password/#view.password.check_password","title":"<code>check_password()</code>","text":"<p>Return <code>True</code> if the user entered the correct password, otherwise <code>False</code>. Original code from: https://docs.streamlit.io/knowledge-base/deploy/authentication-without-sso</p> Source code in <code>view/password.py</code> <pre><code>def check_password():\n\"\"\"Return `True` if the user entered the correct password, otherwise `False`.\n    Original code from:\n    https://docs.streamlit.io/knowledge-base/deploy/authentication-without-sso\n    \"\"\"\n\n    def password_entered():\n\"\"\"Checa se o password inserido \u00e9 correto.\"\"\"\n\n        global user\n        if (\n            st.session_state[\"username\"] in st.secrets[\"passwords\"]\n            and st.session_state[\"password\"] == st.secrets[\"passwords\"][st.session_state[\"username\"]]\n            ):\n            st.session_state[\"password_correct\"] = True\n            st.session_state[\"username\"]\n\n            del st.session_state[\"password\"]  # don't store password\n            user = st.session_state[\"username\"]\n        else:\n            st.session_state[\"password_correct\"] = False\n\n    if \"password_correct\" not in st.session_state:\n        # Primeira execu\u00e7\u00e3o, mostra inputs para usu\u00e1rio.\n        st.text_input(\"Username\", \n                      on_change=password_entered, \n                      key=\"username\")\n        st.text_input(\"Password\", \n                      type=\"password\", \n                      on_change=password_entered, \n                      key=\"password\"\n        )\n        return False\n\n    elif not st.session_state[\"password_correct\"]:\n        # Password nn\u00e3o est\u00e1 correto, mostra input + error.\n        st.text_input(\"Username\", \n                      on_change=password_entered, \n                      key=\"username\")\n        st.text_input(\"Password\", \n                      type=\"password\", \n                      on_change=password_entered, key=\"password\"\n        )\n        st.error(\"\ud83d\ude15 Usu\u00e1rio n\u00e3o conhecido ou password incorreto.\")\n        return False\n\n    else:\n        # Password correto.\n        return True\n</code></pre>"},{"location":"view/password/#descricao-do-codigo","title":"Descri\u00e7\u00e3o do C\u00f3digo","text":"<p>Este c\u00f3digo em Python utiliza a biblioteca Streamlit para criar uma interface de usu\u00e1rio interativa que solicita ao usu\u00e1rio um nome de usu\u00e1rio e uma senha. O objetivo \u00e9 verificar se o usu\u00e1rio forneceu a senha correta associada ao nome de usu\u00e1rio. O c\u00f3digo utiliza o conceito de \"session_state\" para armazenar temporariamente informa\u00e7\u00f5es entre diferentes intera\u00e7\u00f5es do usu\u00e1rio com a aplica\u00e7\u00e3o.</p> <p>O c\u00f3digo original dispon\u00edvel em: https://docs.streamlit.io/knowledge-base/deploy/authentication-without-sso</p> <p>Aqui est\u00e1 uma descri\u00e7\u00e3o detalhada do c\u00f3digo:</p> <ol> <li> <p>O c\u00f3digo importa a biblioteca Streamlit e define uma fun\u00e7\u00e3o chamada <code>check_password()</code> que realiza a verifica\u00e7\u00e3o da senha:</p> </li> <li> <p>Dentro da fun\u00e7\u00e3o <code>check_password()</code>, h\u00e1 uma fun\u00e7\u00e3o interna chamada <code>password_entered()</code>. Esta fun\u00e7\u00e3o \u00e9 usada para verificar se a senha digitada pelo usu\u00e1rio est\u00e1 correta.</p> </li> <li> <p>Na fun\u00e7\u00e3o <code>password_entered()</code>, a senha fornecida pelo usu\u00e1rio \u00e9 comparada com a senha correta armazenada na vari\u00e1vel <code>st.secrets[\"passwords\"]</code>, que \u00e9 uma configura\u00e7\u00e3o secreta definida na aplica\u00e7\u00e3o do Streamlit (mais sobre isso posteriormente). Se a senha estiver correta, a vari\u00e1vel de estado <code>st.session_state[\"password_correct\"]</code> \u00e9 definida como <code>True</code>, indicando que a senha est\u00e1 correta. Em caso contr\u00e1rio, \u00e9 definida como <code>False</code>.</p> </li> <li> <p>A fun\u00e7\u00e3o principal <code>check_password()</code> come\u00e7a verificando se a vari\u00e1vel de estado <code>password_correct</code> n\u00e3o est\u00e1 presente em <code>st.session_state</code>. Isso \u00e9 usado para verificar se \u00e9 a primeira vez que o usu\u00e1rio interage com o aplicativo.</p> </li> <li> <p>Se <code>password_correct</code> ainda n\u00e3o estiver definida, o aplicativo exibe campos de entrada de texto para o usu\u00e1rio digitar seu nome de usu\u00e1rio e senha. Esses campos s\u00e3o vinculados \u00e0 fun\u00e7\u00e3o <code>password_entered()</code> por meio do par\u00e2metro <code>on_change</code>, o que significa que a fun\u00e7\u00e3o ser\u00e1 chamada automaticamente sempre que o conte\u00fado dos campos de entrada for alterado.</p> </li> <li> <p>Se <code>password_correct</code> n\u00e3o estiver definida e o usu\u00e1rio preencher o nome de usu\u00e1rio e a senha, a fun\u00e7\u00e3o <code>password_entered()</code> ser\u00e1 chamada para verificar se a senha est\u00e1 correta. Se estiver correta, a vari\u00e1vel de estado <code>password_correct</code> ser\u00e1 definida como <code>True</code>, caso contr\u00e1rio, ser\u00e1 definida como <code>False</code>.</p> </li> <li> <p>Se <code>password_correct</code> estiver definida, mas seu valor for <code>False</code>, isso significa que o usu\u00e1rio j\u00e1 tentou entrar com a senha, mas a senha estava incorreta. Nesse caso, o aplicativo mostra novamente os campos de entrada de texto para que o usu\u00e1rio possa tentar novamente. Al\u00e9m disso, uma mensagem de erro \u00e9 exibida usando <code>st.error()</code> para informar ao usu\u00e1rio que o nome de usu\u00e1rio n\u00e3o \u00e9 conhecido ou a senha est\u00e1 incorreta.</p> </li> <li> <p>Se a vari\u00e1vel <code>password_correct</code> estiver definida e seu valor for <code>True</code>, isso significa que o usu\u00e1rio inseriu a senha correta. Nesse caso, a fun\u00e7\u00e3o retorna <code>True</code>, indicando que a senha est\u00e1 correta.</p> </li> </ol> <p>Para funcionar corretamente, o c\u00f3digo presume que haja uma configura\u00e7\u00e3o secreta definida no Streamlit com o nome <code>\"passwords\"</code> que mapeia nomes de usu\u00e1rio para suas respectivas senhas corretas. Al\u00e9m disso, \u00e9 necess\u00e1rio que a aplica\u00e7\u00e3o do Streamlit tenha habilitado a funcionalidade de sess\u00e3o para armazenar as vari\u00e1veis de estado entre as intera\u00e7\u00f5es do usu\u00e1rio.</p> <p>Esse c\u00f3digo \u00e9 uma implementa\u00e7\u00e3o b\u00e1sica de autentica\u00e7\u00e3o simples, sem qualquer recurso de armazenamento seguro de senhas ou gerenciamento de usu\u00e1rios. Ele \u00e9 adequado apenas para fins de demonstra\u00e7\u00e3o e pode n\u00e3o ser seguro o suficiente para uso em um ambiente de produ\u00e7\u00e3o. Em aplica\u00e7\u00f5es reais, \u00e9 essencial implementar uma autentica\u00e7\u00e3o mais robusta e segura.</p>"},{"location":"view/password/#sobre-a-funcao-interna","title":"Sobre a fun\u00e7\u00e3o interna.","text":"<p>A fun\u00e7\u00e3o <code>check_password</code> cont\u00e9m outra fun\u00e7\u00e3o chamada <code>password_entered</code>. A estrutura de ter uma fun\u00e7\u00e3o dentro de outra \u00e9 conhecida como fun\u00e7\u00e3o aninhada ou fun\u00e7\u00e3o interna. Essa abordagem \u00e9 usada para encapsular e organizar o c\u00f3digo de maneira mais eficiente, especialmente quando a fun\u00e7\u00e3o interna \u00e9 relevante apenas para a fun\u00e7\u00e3o externa e n\u00e3o precisa ser acessada de outros lugares.</p> <p>Aqui est\u00e3o algumas raz\u00f5es pelas quais voc\u00ea pode encontrar fun\u00e7\u00f5es aninhadas em um c\u00f3digo:</p> <ol> <li> <p>Escopo limitado: A fun\u00e7\u00e3o <code>password_entered</code> \u00e9 \u00fatil apenas para a fun\u00e7\u00e3o <code>check_password</code>. Coloc\u00e1-la dentro da fun\u00e7\u00e3o externa garante que ela s\u00f3 possa ser usada nesse contexto espec\u00edfico.</p> </li> <li> <p>Compartilhamento de vari\u00e1veis: A fun\u00e7\u00e3o interna tem acesso \u00e0s vari\u00e1veis da fun\u00e7\u00e3o externa. Isso \u00e9 \u00fatil para evitar a necessidade de passar essas vari\u00e1veis como argumentos para a fun\u00e7\u00e3o interna.</p> </li> <li> <p>Encapsulamento: A fun\u00e7\u00e3o interna n\u00e3o precisa ser acessada por outras partes do c\u00f3digo. Ao coloc\u00e1-la dentro da fun\u00e7\u00e3o externa, voc\u00ea est\u00e1 indicando claramente que ela \u00e9 relevante apenas para a l\u00f3gica espec\u00edfica da fun\u00e7\u00e3o externa.</p> </li> <li> <p>Organiza\u00e7\u00e3o: Fun\u00e7\u00f5es aninhadas podem ajudar a dividir uma tarefa complexa em etapas menores. Isso pode melhorar a legibilidade e manutenibilidade do c\u00f3digo.</p> </li> <li> <p>Menos polui\u00e7\u00e3o de namespace: Ao usar fun\u00e7\u00f5es internas, voc\u00ea evita poluir o espa\u00e7o de nomes global com fun\u00e7\u00f5es que s\u00f3 s\u00e3o relevantes em um contexto espec\u00edfico.</p> </li> </ol> <p>No caso espec\u00edfico desse c\u00f3digo, a fun\u00e7\u00e3o <code>password_entered</code> \u00e9 uma parte essencial da verifica\u00e7\u00e3o do nome de usu\u00e1rio e senha inseridos. Ela verifica se o nome de usu\u00e1rio e a senha correspondem ao que est\u00e1 armazenado nos segredos do Streamlit e define uma vari\u00e1vel de estado <code>password_correct</code> de acordo. Essa fun\u00e7\u00e3o aninhada \u00e9 usada para modularizar a l\u00f3gica de verifica\u00e7\u00e3o do nome de usu\u00e1rio e senha, tornando o c\u00f3digo mais organizado e leg\u00edvel.</p>"}]}